<!DOCTYPE html>
<html>

<body>
  <style type="text/css">
    body {
      background-color: rgb(255, 255, 255);
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      min-width: 100vw;
      min-height: 100vh;
    }

    canvas {
      border: 1px solid black;
    }
  </style>

  <canvas id="canvas" width="1080" height="720"></canvas>

  <!-- <script src="webgl.js"></script> -->
  <script src="resources/twgl/4.x/twgl-full.min.js"></script>
  <!-- <script src="resources/twgl/4.x/twgl-full.js"></script> -->
  <script src="resources/m3.js"></script>
  <!-- <script src="gl-matrix-min.js"></script> -->
  <script src="tessellate.js"></script>
  <script src="/node_modules/pathkit-wasm/bin/pathkit.js"></script>
  <script src="/node_modules/svg-path-reverse/reverse.js"></script>
  <script src="svgpath-all.js"></script>
  <script src="cubic2quad.js"></script>
  <!-- <script src="/node_modules/svgpath/lib/svgpath.js"></script> -->
  <script type="text/javascript" src="fontkit.js"></script>
  <script src="/node_modules/libtess/libtess.min.js"></script>
  <script src="triangulate.js"></script>

  <script type="text/javascript">
    'use strict';
    // const { mat2, mat3, mat4, vec2, vec3, vec4 } = glMatrix;
    const eps = 0.5;
    const scene = [];
    const FillType = {
      "SOLID": 0,
      "GRADIENT": 1,
      "IMAGE": 2,
      "ADVANCED_IMAGE": 3,
      "CUSTOME": 4,
      "NONE": 5
    };
    const StrokeJoin = {
      "MITER": 0,
      "ROUND": 1,
      "BEVEL": 2,
    };
    const StrokeCap = {
      "BUTT": 0,
      "ROUND": 1,
      "SQUARE": 2,
    };

    // const quads = cubicToQuad(50, 50, 75, 50, 100, 75, 100, 100, eps);
    // console.log(quads);

    // convert svg to quad-only segments
    var transformed = SvgPath('M50,50C75,50,100,75,100,100C75,100,50,125,50,150H111V222L0,0z')
      .unarc();
    const path1 = transformed.iterate((segment, index, x, y) => {
      // console.log(segment); 
    });


    window.onload = (event) => {
      // console.log('page is fully loaded');
    };

    function loadFont(font, path, x, y, scale, str, isInvertedFont) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, true);
      xhr.responseType = 'arraybuffer';

      xhr.onload = function (e) {
        if (this.status == 200) {
          var fkBlob = this.response;
          var fkBuffer = new Buffer(fkBlob);
          font = fontkit.create(fkBuffer);

          addGlyphRun(font, x, y, scale, str, isInvertedFont);
          draw();
        }
      }
      xhr.send();
    }

    function addGlyphRun(font, startX, startY, scale, str, isInvertedFont) {
      if (!font) return;
      let run = font.layout(str);
      let x = startX, y = startY;
      run.glyphs.forEach((glyph, index) => {
        const pos = run.positions[index];
        const glyphString = run.glyphs[index].path.toSVG();
        if (glyphString.length > 0) {
          // swtich to y coordinate
          const inverted = SvgPath(glyphString).scale(1, -1).toString();
          let si = null;
          if (!isInvertedFont) {
            si = shapeFromSvgString(inverted);
          } else {
            si = shapeFromSvgString(glyphString);
          }

          addShape(x + pos.xOffset * scale, y + pos.yOffset * scale, scale, [0, 0, 0, 1], si, isInvertedFont, FillType.IMAGE);
        }
        x += pos.xAdvance * scale;
        y += pos.yAdvance * scale;
      });
    }

    // font family (typeface), otf font has inverted winding
    // let font1 = null, font2 = null, font3 = null, font4 = null;
    // const yOff = 300;
    // const testString = 'Hello world Path rendering!';
    // loadFont(font1, 'Roboto-Regular.ttf', 200, 500 + yOff, 0.05, testString, false);
    // loadFont(font2, 'Roboto-Italic.ttf', 200, 700 + yOff, 0.05, testString);
    // loadFont(font3, 'Roboto-Medium.ttf', 200, 900 + yOff, 0.05, testString);
    // loadFont(font4, 'Roboto-MediumItalic.ttf', 200, 1100 + yOff, 0.05, testString);


    // console.log('\u4F60\u597D\u66F2\u7EBF\u6E32\u67D3'); // 你好曲线渲染
    // console.log('\u3053\u3093\u306B\u3061\u306F\u30D1\u30B9\u30EC\u30F3\u30C0\u30EA\u30F3\u30B0'); // 你好曲线渲染

    // let fontCh = null;
    // loadFont(fontCh, 'NotoSansSC-Regular.otf', 200, 1300 + yOff, 0.1, '\u4F60\u597D\u66F2\u7EBF\u6E32\u67D3', true);

    // let fontCJK = null;
    // loadFont(fontCJK, 'NotoSansCJKjp-Regular.otf', 200, 1500 + yOff, 0.1, '\u3053\u3093\u306B\u3061\u306F\u30D1\u30B9\u30EC\u30F3\u30C0\u30EA\u30F3\u30B0', true);


    let showWireframe = false;
    const MIN_ZOOM = 0.01;
    const MAX_ZOOM = 4000;

    // load pathkit first, to handle geometry
    PathKitInit({
      locateFile: (file) => '/node_modules/pathkit-wasm/bin/' + file,
    }).then((PathKit) => {
      // Code goes here using PathKit
      console.log('initialized pathkit');
      window.PathKit = PathKit;

      // const path = PathKit.FromSVGString(
      //   'M44.4,20.8c1.5,1.6,13,15.7,13,15.7s-6.4,6.1-6.4,12.5c0,7.5,8.6,14.3,8.6,14.3l-0.9,1.1c-3.3-1.9-8.9-2.1-11.4,0.8c-3.1,3.6,3.9,9.1,3.9,9.1l-0.8,1.1c-2.4-1.8-12.6-11.4-8.3-16.1c2.6-2.9,5.8-3.8,10.3-1.4l-12.1-12.5c7-8.6,8.2-11.1,8.2-13.4c0-4.8-3.4-8.2-5.1-10.4c-0.6-0.9-1.7-1.6-1-2.2C43.1,18.9,43.5,19.7,44.4,20.8z');
      // const bb = path.computeTightBounds();
      // console.log(bb);
      // // console.log(path);

      // const box = PathKit.NewPath().rect(0, 0, 100, 100);
      // // box.dash(20, 10, 3);
      // const boxCmd = box.toCmds();
      // console.log(boxCmd);
      // // Stroke the path with width 10 and rounded corners
      // let rounded = box.copy().stroke({ width: 10, join: PathKit.StrokeJoin.ROUND });
      // const roundCmd = rounded.toCmds();
      // console.log(rounded.toSVGString());

      const lineString = "M 0,0 L 50, 100 L 100, 0";
      const stroke1 = calcStrokePath(lineString, 10, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.BUTT);
      addShape(-50, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke1), false, FillType.SOLID);

      const stroke2 = calcStrokePath(lineString, 10, PathKit.StrokeJoin.BEVEL, PathKit.StrokeCap.ROUND);
      addShape(50, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke2), false, FillType.SOLID);

      const stroke3 = calcStrokePath(lineString, 10, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.SQUARE);
      addShape(150, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke3), false, FillType.SOLID);

      const stroke4 = calcStrokePath(lineString, 10, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.SQUARE, [10, 20, 3]);
      addShape(250, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke4), false, FillType.SOLID);

      const stroke5 = calcStrokePath(lineString, 5, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.SQUARE, [5, 8, 3]);
      addShape(350, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke5), false, FillType.SOLID);

      const stroke6 = calcStrokePath(lineString, 2, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.SQUARE);
      addShape(450, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke6), false, FillType.SOLID);

      const stroke7 = calcStrokePath(lineString, 1, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.ROUND);
      addShape(550, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke7), false, FillType.SOLID);

      const stroke8 = calcStrokePath(lineString, 15, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.ROUND);
      addShape(650, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke8), false, FillType.GRADIENT);

      const stroke9 = calcStrokePath(lineString, 15, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.ROUND, [10, 20, 0]);
      addShape(750, 300, .8, [1, 0, 0, 0.8], shapeFromSvgString(stroke9), false, FillType.IMAGE);


      // test shape with border on fill
      const testString = 'M0,50L50,50C75,50,100,75,100,100C75,100,50,125,50,150z';
      addShape(350, 0, 1, [0, 0, 1, 0.9], shapeFromSvgString(testString), false, FillType.GRADIENT); // fill
      const testStroke = calcStrokePath(testString, 9, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND);
      const testReversed = SVGPathEditor.reverse(testStroke, 0);
      addShape(350, 0, 1, [0, 0, 1, 0.6], shapeFromSvgString(testReversed), false, FillType.SOLID); // stroke with fill

      // blob border
      const blobString = "M -60.48,12.9 C -70.783,-24.08,-114.688,-53.32,-112,-77.4 C -109.312,-101.48,-77.0,-108.79,-47.0-107.5 C -17.024,-106.21,13.4,-94.6,38.0,-70.94 C 62.7,-47.2,77.056,-22.7,76.16,10.75 C 75.264,44.2,60.928,77.4,33.5,96.75 C 6.2,116.1,-41.664,124.27,-60.48,107.5 C -79.2,90.73,-50.1,49.8,-60.48,12.9 Z";
      addShape(480, 220, .5, [0, 0, 1, 0.5], shapeFromSvgString(blobString), false, FillType.IMAGE);// fill 
      const blobStrokeStr = calcStrokePath(blobString, 15, PathKit.StrokeJoin.ROUND, PathKit.StrokeCap.ROUND);
      const reversed = SVGPathEditor.reverse(blobStrokeStr);
      addShape(480, 220, .5, [1, 0, 0, 1], shapeFromSvgString(reversed), false, FillType.SOLID); // stroke with fill

      // stroke-on-stroke example
      // {
      //   const pathStr = 'M0,0L25,100';
      //   const stroked = calcStrokePath(pathStr, 10, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND);
      //   addShape(0, 600, 1, [0.75, 0.88, 0.88, 1], shapeFromSvgString(stroked), false, FillType.SOLID);

      //   const stroked1 = calcStrokePath(stroked, 2, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND);
      //   addShape(100, 600, 1, [0.75, 0.88, 0.88, 1], shapeFromSvgString(stroked), false, FillType.SOLID); // fill
      //   addShape(100, 600, 1, [0, 0, 0, .9], shapeFromSvgString(stroked1), false, FillType.SOLID); // stroke
      // }

      // {
      //   const pathStr = 'M0,0L25,100';
      //   const stroked = calcStrokePath(pathStr, 20, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND);
      //   const stroked1 = calcStrokePath(stroked, 2, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND);
      //   addShape(200, 600, 1, [0.75, 0.88, 0.88, 1], shapeFromSvgString(stroked), false, FillType.SOLID); // fill
      //   addShape(200, 600, 1, [0, 0, 0, .9], shapeFromSvgString(stroked1), false, FillType.SOLID); // stroke
      // }

      // {
      //   const pathStr = 'M0,0L25,100';
      //   const stroked = calcStrokePath(pathStr, 20, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND);
      //   const stroked1 = calcStrokePath(stroked, 2, PathKit.StrokeJoin.MITER, PathKit.StrokeCap.ROUND, [5, 5, 1]);
      //   const rev1 = SVGPathEditor.reverse(stroked1); // have to reverse??
      //   addShape(300, 600, 1, [0.75, 0.88, 0.88, 1], shapeFromSvgString(stroked), false, FillType.SOLID); // fill
      //   addShape(300, 600, 1, [0, 0, 0, .9], shapeFromSvgString(rev1), false, FillType.SOLID); // stroke
      // }



      // pattern fill with border and attachment shapes inside
      {
        // base fill
        const patternFillString = 'M33.96 342.31C5.27 340.82 -0.91 317.47 -0.06 303.94Q1.55 277.99 3.17 252.04C4 238.79 5.09 226.39 6.13 214.4 7.19 202.38 8.27 189.94 9.09 176.61 9.61 168.26 9.9 158.7 10.18 149.45 10.46 140.26 10.74 130.75 11.27 122.51 11.97 111.23 12.59 99.76 13.2 88.67 13.81 77.63 14.43 66.2 15.14 54.99 15.7 46.05 16.4 36.87 17.25 27.69 17.69 22.87 20.17 17.25 24.56 16.32 24.98 16.23 25.41 16.19 25.84 16.22 28.37 16.36 30.42 18.78 30.72 21.96 30.87 25.35 30.67 28.74 30.1 32.08 29.87 33.77 29.65 35.51 29.51 37.21 28.98 43.54 28.65 48.82 28.45 53.85 28.31 58.7 31.86 62.75 36.43 62.9 39.77 63.11 42.87 61.09 44.24 57.85 45.53 54.86 45.38 51.32 45.25 48.2 45.2 47.11 45.16 46.08 45.18 45.2 45.22 43.62 45.19 41.84 45.17 39.96 45.1 35.38 45.04 30.18 45.92 25.73 46.84 21.11 48.53 18.32 51.24 16.96 52.31 16.42 53.47 16.14 54.65 16.17 56.1 16.18 57.47 16.86 58.43 18.04 59.35 19.29 59.73 20.93 59.48 22.52 59.03 26.41 58.69 29.85 58.43 33.05 57.8 39.93 57.59 46.84 57.8 53.73 58.08 59.54 62.52 64.1 67.99 64.18 72.44 64.44 76.47 61.44 77.78 56.9 78.36 54.7 78.55 52.39 78.34 50.11Q78.33 49.96 78.33 49.82C78.02 43.6 78.22 37.36 78.89 31.17 79.01 30.29 79.09 29.4 79.18 28.52 79.55 24.49 79.85 21.3 82.33 18.92 83.54 17.78 85.09 17.16 86.68 17.18 87.35 17.2 88.02 17.35 88.64 17.63 90.96 18.72 91.54 22.58 91.68 24.2 91.82 26.75 91.71 29.32 91.39 31.85 91.25 33.3 91.1 34.8 91.04 36.31 90.77 41.85 90.71 46.7 90.84 51.11 91.1 59.64 95.35 65.01 101.93 65.1Q102.06 65.11 102.19 65.11C105.19 65.09 108.03 63.75 110.07 61.42 112.15 59.05 113.23 55.88 113.09 52.63 112.7 43.53 112.51 36.52 112.54 31.78 112.54 30.92 112.53 30.02 112.51 29.12 112.45 25.82 112.38 22.4 113.54 19.89 114.39 17.93 116.01 16.51 117.93 16.03 118.21 15.97 118.5 15.94 118.78 15.94 122.27 15.94 125.18 20.54 125.35 24.51 125.56 29.08 125.49 33.8 125.44 38.36 125.39 42.38 125.33 46.53 125.46 50.63 125.74 59.64 130.17 65.22 137.03 65.17 142.83 65.11 147.01 60.77 148.19 53.58 149.48 45.51 149.3 37.21 149.01 29.41 148.96 28.13 148.83 26.88 148.7 25.67 148.26 21.55 148.1 19.11 150.02 16.99 151.16 15.77 152.68 15.07 154.27 15.04 154.71 15.03 155.15 15.07 155.59 15.17 160.03 16.22 160.59 21.01 160.94 28.21 161.13 32.08 161.03 36.05 160.94 39.88 160.87 42.81 160.79 45.84 160.85 48.79 160.86 49.31 160.86 49.85 160.85 50.41 160.85 54.33 160.84 59.2 163.71 62.23 167.34 65.53 172.7 65.24 175.98 61.59 178.67 58.18 178.42 52.98 177.92 48.83 177.27 43.46 176.54 37.38 176.16 31.36 176.12 30.64 176.06 29.88 176 29.09 175.59 23.77 175.08 17.17 178.56 14.45 179.5 13.73 180.61 13.34 181.75 13.3 182.81 13.25 183.86 13.51 184.79 14.06 187.47 15.68 188.11 18.95 188.34 24.42 188.72 33.39 189.5 42.48 190.69 51.48 191.49 58.24 196.91 63.27 203.22 63.13Q203.32 63.13 203.41 63.12C209.52 62.78 214.29 57.51 214.75 50.61 215.05 45.12 214.88 39.61 214.24 34.14 214.05 32.28 213.76 30.41 213.47 28.6 212.96 25.71 212.64 22.78 212.55 19.84 212.49 17.73 212.95 15.63 213.9 13.81 214.66 12.23 216.07 11.18 217.67 10.98 219.74 10.85 221.87 12.5 222.96 15.1 224.67 19.12 225.15 23.91 225.62 28.53 225.71 29.44 225.8 30.35 225.9 31.24 227.08 41.86 228.19 52.48 229.19 62.82 230.3 74.24 231.08 86.65 231.84 98.66 232.22 104.85 232.59 110.71 233 116.45 234.48 137.14 236.09 157.69 237.65 177.56 239.44 200.3 241.31 223.82 242.96 247.53 243.99 262.39 244.74 273.74 245.31 282.41 245.75 289.02 246.09 294.08 246.37 297.96 247.65 315.76 243.46 327.72 233.54 334.48 224.96 340.25 213.34 341.32 203.13 341.8Q200.5 341.91 197.88 342.01C186.87 342.43 178.68 342.51 170.78 342.56 163.1 342.56 155.17 342.54 144.58 342.67Q143.01 342.69 141.43 342.71C120.92 342.8 104.21 343.11 88.07 343.25 71.72 343.27 54.85 343.15 33.96 342.31Q33.96 342.31 33.96 342.31z';
        addShape(350, 600, 1, [.749, .671, .624, 1], shapeFromSvgString(patternFillString), false, FillType.SOLID); // fill

        // stroke fill
        const patternStrokeString = 'M217.87 13.97C218.66 13.92 219.82 14.64 220.54 16.34 222.05 19.9 222.47 24.23 222.92 28.81 223.01 29.74 223.11 30.65 223.2 31.56 224.36 42.17 225.45 52.77 226.42 63.08 227.5 74.46 228.26 86.84 228.99 98.82 229.36 105.03 229.72 110.89 230.12 116.66 231.56 137.35 233.13 157.9 234.65 177.78 236.39 200.52 238.21 224.04 239.81 247.74 240.82 262.6 241.56 274.17 242.11 282.61 242.52 289.14 242.86 294.29 243.13 298.18 244.29 314.89 240.53 325.99 231.58 332.08 223.74 337.35 212.71 338.34 202.99 338.8Q201.62 338.86 200.3 338.92 198.99 338.97 197.75 339.01C186.8 339.43 179.01 339.51 170.76 339.56 163.09 339.57 155.15 339.54 144.55 339.67Q142.96 339.69 141.38 339.71C120.88 339.8 104.17 340.11 88.02 340.25 71.74 340.27 54.91 340.16 34.1 339.33 22.65 338.78 14.13 334.49 8.81 326.61 4.75 320.55 2.62 312.14 3.11 304.15Q4.69 278.19 6.27 252.23C7.08 239.02 8.15 226.64 9.19 214.66 10.22 202.62 11.29 190.15 12.09 176.79 12.6 168.39 12.87 158.8 13.13 149.54 13.39 140.37 13.68 130.89 14.18 122.69 14.86 111.4 15.47 99.92 16.06 88.83 16.64 77.79 17.26 66.37 17.94 55.16 18.49 46.26 19.18 37.1 20 27.96 20.35 24.1 22.19 19.87 25.06 19.26 25.25 19.22 25.46 19.2 25.66 19.21 26.98 19.29 27.83 20.86 27.96 22.3 28.09 25.43 27.88 28.59 27.33 31.68 27.11 33.4 26.86 35.19 26.72 36.96 26.18 43.33 25.84 48.66 25.64 53.75 25.4 60.24 30.15 65.68 36.28 65.9 40.77 66.17 44.96 63.46 46.78 59.09 48.37 55.43 48.18 51.34 48.04 48.05 47.99 47.02 47.95 46.03 47.98 45.26 48.02 43.61 47.99 41.81 47.96 39.9 47.85 32.35 47.7 22.02 52.37 19.68 53.05 19.33 53.78 19.15 54.52 19.17 55.21 19.16 55.85 19.45 56.33 19.98 56.74 20.61 56.88 21.41 56.73 22.16 56.28 26.08 55.93 29.56 55.66 32.8 55.02 39.8 54.79 46.84 54.99 53.86 55.29 61.24 60.94 67.07 67.89 67.18 73.58 67.46 78.73 63.62 80.45 57.83 81.13 55.28 81.37 52.61 81.14 49.97Q81.12 49.83 81.12 49.68C80.82 43.64 80.99 37.57 81.64 31.54 81.76 30.61 81.84 29.69 81.92 28.81 82.29 24.85 82.55 22.7 84.14 21.17 84.83 20.53 85.71 20.18 86.61 20.19 86.94 20.19 87.26 20.25 87.57 20.39 88.01 20.6 88.73 22.02 88.95 24.49 89.05 26.84 88.95 29.21 88.64 31.55 88.5 33.03 88.35 34.58 88.27 36.17 87.99 41.79 87.93 46.71 88.05 51.22 88.35 61.35 93.78 67.98 101.9 68.1 102 68.11 102.12 68.11 102.22 68.11 105.98 68.08 109.55 66.4 112.12 63.47 114.71 60.51 116.07 56.54 115.89 52.48 115.48 43.44 115.28 36.49 115.3 31.8 115.3 30.88 115.28 29.95 115.26 29.05 115.2 26.12 115.13 23.09 115.98 21.24 116.45 20.13 117.34 19.3 118.42 18.98 118.54 18.95 118.66 18.94 118.78 18.94 120.46 18.94 122.51 21.98 122.62 24.65 122.82 29.12 122.75 33.59 122.69 38.31 122.63 42.36 122.57 46.55 122.69 50.73 123 61.36 128.64 68.22 137.05 68.17 144.23 68.09 149.54 62.68 150.91 54.09 152.25 45.74 152.05 37.26 151.74 29.29 151.69 27.89 151.54 26.59 151.41 25.32 150.98 21.38 151 20.16 151.95 19.11 152.59 18.43 153.45 18.05 154.33 18.04 154.57 18.02 154.8 18.05 155.04 18.1 157.06 18.58 157.84 20.2 158.22 28.34Q158.22 28.38 158.23 28.42C158.4 32.1 158.3 36 158.2 39.79 158.12 42.75 158.04 45.82 158.09 48.84 158.11 49.33 158.1 49.85 158.09 50.39 158.08 54.63 158.05 60.44 161.77 64.37 166.55 68.87 173.8 68.51 178.12 63.54 181.53 59.18 181.21 52.85 180.66 48.45 180.01 43.12 179.27 37.09 178.89 31.17 178.84 30.43 178.78 29.65 178.72 28.85 178.38 24.54 177.91 18.63 180.13 16.9 181.14 16.17 182.44 16.09 183.53 16.69 184.9 17.52 185.44 19.5 185.64 24.52 186 33.59 186.78 42.79 187.96 51.87 188.94 60.16 195.59 66.32 203.35 66.13Q203.46 66.12 203.58 66.12C211.09 65.7 216.95 59.26 217.51 50.86 217.81 45.18 217.62 39.48 216.95 33.83 216.74 31.89 216.45 29.97 216.16 28.13 215.67 25.39 215.36 22.63 215.26 19.86 215.18 18.31 215.5 16.79 216.17 15.44 216.51 14.7 217.13 14.16 217.87 13.97M217.48 7.98C215.02 8.22 212.85 9.78 211.62 12.16 210.39 14.46 209.78 17.11 209.86 19.8 209.86 24.64 211.04 29.61 211.53 34.43 212.13 39.71 212.29 45.04 212.01 50.35 211.64 55.55 208.24 59.84 203.25 60.12Q203.18 60.12 203.1 60.12C198.23 60.19 194.06 56.29 193.42 51.06Q191.66 37.75 191.06 24.31C190.84 19.44 190.38 14.02 186.07 11.42 183.17 9.73 179.69 9.94 177 11.98 171.65 16.14 173.07 25.34 173.44 31.54 173.8 37.44 174.48 43.33 175.19 49.2 175.79 54.16 176.02 61.32 169.75 61.52 162.91 61.72 163.71 53.78 163.62 48.74 163.49 42.01 164.03 34.98 163.68 28.12 163.35 21.76 162.98 13.84 156.15 12.23 155.51 12.08 154.86 12.01 154.21 12.03 151.93 12.07 149.74 13.08 148.11 14.85 144.31 19.04 146.1 24.34 146.28 29.51 146.56 37.35 146.71 45.29 145.46 53.04 144.64 57.94 142.01 62.12 137 62.17 130.7 62.21 128.43 56.3 128.25 50.53 127.97 41.83 128.49 33.04 128.09 24.35 127.84 19.05 123.93 12.94 118.79 12.94 118.34 12.94 117.9 12.98 117.45 13.07 114.7 13.73 112.36 15.73 111.11 18.52 109.28 22.48 109.83 27.46 109.79 31.76 109.75 37.24 109.99 45.05 110.32 52.77 110.44 55.17 109.63 57.52 108.1 59.29 106.57 61.05 104.44 62.06 102.18 62.1Q102.08 62.1 101.98 62.09C96.04 62.01 93.81 56.52 93.63 51 93.48 46.15 93.58 41.29 93.8 36.44 93.98 32.27 94.79 28.05 94.42 23.89 94.1 20.39 92.89 16.35 89.73 14.87 88.78 14.43 87.77 14.19 86.75 14.18 84.47 14.14 82.27 15.02 80.54 16.66 76.58 20.45 76.81 25.6 76.17 30.78 75.46 37.14 75.24 43.55 75.54 49.95 75.75 51.95 75.6 53.99 75.13 55.95 74.19 59.22 71.28 61.39 68.09 61.19 64.08 61.19 60.8 57.85 60.6 53.59 60.39 46.82 60.59 40.05 61.18 33.29 61.47 29.81 61.82 26.33 62.2 22.87 62.6 20.46 61.99 17.98 60.56 16.12 59.12 14.24 57 13.17 54.77 13.18 53.16 13.12 51.57 13.49 50.1 14.24 40.56 19 42.66 36 42.39 45.13 42.29 48.61 43.09 53.36 41.68 56.6 40.81 58.73 38.76 60.07 36.58 59.92 35.12 59.88 33.73 59.24 32.74 58.12 31.75 56.99 31.22 55.49 31.26 53.94 31.46 48.44 31.83 42.95 32.27 37.45 32.69 32.34 33.95 26.75 33.46 21.63 33.03 17.13 30.03 13.45 26.02 13.23 25.36 13.19 24.7 13.24 24.05 13.38 18.15 14.64 15.02 21.5 14.48 27.43Q13.2 41.11 12.32 54.81C10.88 77.3 9.78 99.83 8.34 122.32 7.28 138.92 7.16 159.82 6.1 176.42 4.42 202.99 1.75 225.27 0.05 251.84 -1.42 274.99 -1.78 280.59 -3.26 303.74 -4.25 319.19 3.14 343.7 33.84 345.31 54.68 346.14 71.3 346.27 87.84 346.26 104.4 346.1 120.87 345.8 141.46 345.71Q143.04 345.69 144.61 345.67C166.2 345.33 176.34 345.76 198 345 199.68 344.93 201.45 344.87 203.26 344.79 224.19 343.73 252.74 340.17 249.61 297.72 248.95 288.76 247.97 273.47 246.09 247.3 244.51 225.1 242.77 203.43 241.02 181.76 239.27 160.09 237.52 138.42 235.89 116.23 234.63 99.07 233.66 79.75 231.95 62.53Q230.4 46.7 228.61 30.91C227.96 25.2 227.66 19.13 225.4 13.84 223.76 10 220.59 7.77 217.48 7.98Q217.48 7.98 217.48 7.98z';
        const rev = SVGPathEditor.reverse(patternStrokeString);
        addShape(350, 600, 1, [.459, .349, .282, 1], shapeFromSvgString(rev), false, FillType.SOLID); // stroke fill

        // inside
        const attachString = 'M84.88 264.39C84.32 291.23 108.16 313.36 138.19 313.37 168.28 312.87 191.88 290.32 190.85 263.49 189.81 236.65 165.87 215.62 137.4 216.09 108.94 216.09 85.44 237.53 84.88 264.39Q84.88 264.39 84.88 264.39z';
        const rev1 = SVGPathEditor.reverse(attachString);
        addShape(350, 600, 1, [.651, .553, .502, 1], shapeFromSvgString(rev1), false, FillType.SOLID); // fill
      }


    });

    function calcStrokePath(svgStr, strokeWidth, joinType, capType, dash) {
      if (!window.PathKit) return '';
      const linePath = window.PathKit.FromSVGString(svgStr);
      if (dash && dash.length === 3) {
        linePath.dash(dash[0], dash[1], dash[2]);
      }
      linePath.stroke({ width: strokeWidth, join: joinType, cap: capType }).simplify();
      const strokeString = linePath.toSVGString();
      linePath.delete();
      return strokeString;
    }

    /* global document, window, twgl, m3 */
    const canvas = document.querySelector('canvas');
    const desiredWidthInCSSPixels = canvas.width; // the css pixe size at the top of this file
    const desiredHeightInCSSPixels = canvas.height;
    canvas.style.width = desiredWidthInCSSPixels + "px";
    canvas.style.height = desiredHeightInCSSPixels + "px";
    var devicePixelRatio = window.devicePixelRatio || 1;
    canvas.width = desiredWidthInCSSPixels * devicePixelRatio;
    canvas.height = desiredHeightInCSSPixels * devicePixelRatio;

    console.log('canvas size:' + canvas.width + ',' + canvas.height);
    const gl = canvas.getContext('webgl2'); // may need to fallback to webgl 1.0
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    // create a texture for test
    var fill_texture = addImageTexture('leaf.jpg');
    var background_texture = addImageTexture('stone.jpg');
    function addImageTexture(file) {
      var newTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, newTexture);
      // Fill the texture with a 1x1 blue pixel.
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
        new Uint8Array([0, 0, 255, 255]));
      // Asynchronously load an image
      var image = new Image();
      image.src = file;
      image.addEventListener('load', function () {
        // Now that the image has loaded make copy it to the texture.
        gl.bindTexture(gl.TEXTURE_2D, newTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // Check if the image is a power of 2 in both dimensions.
        if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
          // Yes, it's a power of 2. Generate mips.
          gl.generateMipmap(gl.TEXTURE_2D);
        } else {
          // No, it's not a power of 2. Turn of mips and set wrapping to clamp to edge
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        }
      });
      return newTexture;
    }

    function isPowerOf2(value) {
      return (value & (value - 1)) === 0;
    }

    const vs = `
attribute vec2 a_position;
uniform mat3 u_matrix;
void main() {
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
}
`;

    const fs = `
precision mediump float;
uniform vec4 u_color;
void main() {
  gl_FragColor = u_color;
}
`;

    const loopvs_gl1 = `
// #version 100 es
attribute vec2 a_position;
attribute vec2 a_texcoord;
attribute float a_winding;
varying vec2 v_texcoord;
varying float v_winding;
uniform mat3 u_matrix;
void main() {
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
  v_texcoord = a_texcoord;
  v_winding = a_winding;
}
`;

    const loopfs_gl1 = `
// #version 100 es
precision mediump float;
uniform vec4 u_color;
varying vec2 v_texcoord;
varying float v_winding;
void main() {
  //gl_FragColor = u_color;
  //  gl_FragColor = vec4(v_texcoord, 1, 1);
  // gl_FragColor = vec4(vec2(v_winding, v_winding) - v_texcoord, 1, 1);

  float u = v_texcoord.x;
  float v = v_texcoord.y;
  float val = (u * u - v) * v_winding;
  if (val > 0.0) discard;

  gl_FragColor = vec4(u, v, 1, 1);
}
`;

    const loopvs_gl2 = `
#version 300 es
in vec2 a_position;
in vec2 a_texcoord;
in vec2 a_fillTexcoord;
in float a_winding;
out vec2 v_texcoord;
out vec2 v_fillTexcoord;
out float v_winding;
uniform mat3 u_matrix;
out vec2 startPos;
out vec2 endPos;
void main() {
  gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
  v_texcoord = a_texcoord;
  v_fillTexcoord = a_fillTexcoord;
  v_winding = a_winding;

  vec4 clipStart= vec4((u_matrix * vec3(0, 0, 1)).xy, 0, 1);
  startPos = clipStart.xy / clipStart.w;
  vec4 clipEnd = vec4((u_matrix * vec3(200, 200, 1)).xy, 0, 1);
  endPos = clipEnd.xy / clipEnd.w;
}
`;

    const loopfs_gl2 = `
    #version 300 es
    precision highp float;
    uniform vec4 u_color;
    in vec2 v_texcoord;
    in vec2 v_fillTexcoord;
    in float v_winding;
    out vec4 outColor;
    uniform mat3 u_matrix;
    in vec2 startPos;
    in vec2 endPos;
    uniform sampler2D u_fillSampler;
    uniform sampler2D u_backgroundSampler;
    uniform int u_fillType;
    void main() {
      // texture color
      // outColor = texture(u_fillSampler, v_texcoord);
      vec4 texColor = texture(u_fillSampler, v_fillTexcoord);
      vec4 backgroundColor = texture(u_backgroundSampler, v_fillTexcoord);
      float gray = 0.2989* backgroundColor.r + 0.5870*backgroundColor.g + 0.1140*backgroundColor.b;
    
      // gradient color
      // todo: resolution will be uniform
      vec2 res = vec2(2160,1440);
      vec2 uv = gl_FragCoord.xy / res.xy;
      vec2 cc = (uv * 2.0 - 1.0);// gl_FragCoord.w;
      float d0 = distance(cc, startPos);
      float d1 = distance(cc, endPos);
      float t = d0 / (d0+d1);
      // todo: colors should be set through uniform
      vec4 startColor = vec4(1.0, 0.0, 0.0, u_color.a);
      vec4 endColor = vec4(0.0, 0.0, 1.0, u_color.a);
      vec4 fillColor = mix(startColor, endColor, smoothstep(0.0, 1.0, t));
    
      float clampedAlpha = 1.0;
      if (abs(v_winding) < 0.0001) {
        // internal polygons
        // outColor = u_color;
      } else {
        // ear triangles
        float u = v_texcoord.x;
        float v = v_texcoord.y;
        float val = (u * u - v) * v_winding;
        
        // float ddx = dFdx(val);
        // float ddy = dFdy(val);
        // float scale = sqrt(ddx * ddx + ddy * ddy);
        float scale = fwidth(val);
        float sd = val / scale;
        float alpha = 0.5 - sd;
        
        // no AA version
        //  if (val < 0.0) discard;
        // outColor = u_color;
        // outColor = vec4(u, v, 1, 1);
        // outColor = vec4(0, 0, 1, alpha);
        // outColor = vec4(alpha, 0, 0, 1); // to debug alpha
      
        // the alpha used to feather curved edges, todo: we need for polyline as well
        clampedAlpha = clamp(alpha, 0.0, 1.0);
      }

      // assembly the color
        if (u_fillType == 0) {
          // solid fill
          outColor = vec4(u_color.rgb, clampedAlpha * u_color.a);
        } else if (u_fillType == 1) {
          // gradient fill
          outColor = vec4(fillColor.rgb, clampedAlpha * fillColor.a);
        } else if (u_fillType == 2) {
          // image fill
          outColor = vec4(texColor.rgb, clampedAlpha * texColor.a);
        } else if (u_fillType == 3) {
          // advanced image fill 
          vec3 comp = mix(u_color.rgb,backgroundColor.rgb, 0.4);
          outColor = vec4(comp, clampedAlpha * u_color.a);
        } else if (u_fillType == 4) {
          // todo: custom fill
          outColor = vec4(vec3(1,0,0), clampedAlpha);
        } else {
          // no fill
          discard;
        }
    }
    `;

    function calcWinding(p0, p1, p2) {
      const v1 = [p1[0] - p0[0], p1[1] - p0[1]];
      const v2 = [p2[0] - p1[0], p2[1] - p1[1]];
      const winding = (v1[0] * v2[1] - v1[1] * v2[0] < 0.0) ? -1 : 1;
      return winding;
    }

    // construct geometry by iterating SkPath
    function shapeFromSkPath(skpath) {

    }

    // construct shape's (polyline/ears) and add to scene
    function shapeFromSvgString(svgstr) {
      // convert arc to Q or C, make sure only C, Q, L, H, V 

      // const inputPath = SvgPath('M0,50L50,50Q100,50,100,100Q50,100,50,150z').unarc();
      // const inputPath = SvgPath('M0,50L50,50Q100,50,100,100Q50,100,50,150 M25,60L50,60L50,80z').unarc();
      // const inputPath = SvgPath('M0,50L50,50Q100,50,100,100Q50,100,50,150 M25,60Q50,60,50,80z').unarc();
      // const inputPath = SvgPath('M0,50L50,50C75,50,100,75,100,100C75,100,50,125,50,150z').unarc();
      // const inputPath = SvgPath('M0,50H50C75,50,100,75,100,100C75,100,50,125,50,150z').unarc(); // test 'H'
      const inputPath = SvgPath(svgstr).unarc();

      // output data, may have multiple contour
      let polyContours = []; // array of point contours
      let earPoints = []; // all triangles with duplicates [p0, p1, p2, p3, p4, p5...]
      let quadEars = [];

      let earPtIdx = -1;
      let curPt = undefined;
      let curPoly = [];
      let lastVerb = undefined;

      inputPath.iterate((segment, index, x, y) => {
        // console.log(segment);
        const verb = segment[0];

        if (verb === 'M') {
          if (curPoly.length >= 6) {
            // last countour finishes
            polyContours.push(curPoly);
            curPoly = [segment[1], segment[2]];
          } else {
            curPoly.push(segment[1], segment[2]);
          }

          curPt = [segment[1], segment[2]];
        }
        else if (verb === 'H') {
          curPt = [segment[1], curPt[1]];
          curPoly.push(...curPt);
          // empty for now
        } else if (verb === 'V') {
          curPt = [curPt[0], segment[1]];
          curPoly.push(...curPt);
          // empty for now
        } else if (verb === 'L') {
          curPt = [segment[1], segment[2]];
          curPoly.push(...curPt);
        } else if (verb === 'Q') {
          // compute this winding
          const p0 = curPt, p1 = [segment[1], segment[2]], p2 = [segment[3], segment[4]];
          const winding = calcWinding(p0, p1, p2);

          // update ears
          if (lastVerb !== verb) {
            earPtIdx++;
            earPoints.push(...p0);
          }
          earPoints.push(...p1, ...p2);
          quadEars.push([earPtIdx, earPtIdx + 1, earPtIdx + 2, winding]);
          earPtIdx += 2;

          // update inner
          if (winding > 0) {
            // control point is outside the cage
            curPoly.push(...p2);
          } else {
            // control point is inside the cage
            curPoly.push(...p1, ...p2);
          }
          curPt = p2;
        } else if (verb === 'C') {
          if (segment.length == 7) {
            const quads = cubicToQuad(curPt[0], curPt[1], segment[1], segment[2], segment[3], segment[4], segment[5], segment[6], eps);
            const nPoints = quads.length / 2;
            const nSeg = (nPoints - 1) / 2;
            const cur = [quads[0], quads[1]];

            const points = [];
            for (let i = 0; i < nPoints; i++) {
              points.push([quads[2 * i], quads[2 * i + 1]]);
            }

            // loop each segment
            for (let i = 0; i < nSeg; i++) {
              const p0 = points[2 * i + 0], p1 = points[2 * i + 1], p2 = points[2 * i + 2];
              const winding = calcWinding(p0, p1, p2);

              // update ear data if is continued quad, already pushed
              if (i === 0 && lastVerb !== 'Q') {
                earPtIdx++;
                earPoints.push(...p0);
              }
              // for ears, just push the cage
              earPoints.push(...p1, ...p2);
              quadEars.push([earPtIdx, earPtIdx + 1, earPtIdx + 2, winding]);
              earPtIdx += 2;

              // update inner, for polyline, only push the inner control point of an ear
              if (winding > 0) {
                // control point is outside the cage
                curPoly.push(...p2);
              } else {
                // control point is inside the cage
                curPoly.push(...p1, ...p2);
              }
            } // end of loop

            curPt = [quads[quads.length - 2], quads[quads.length - 1]];
          }
        } else if (verb === 'z' || verb === 'Z') {
          if (curPoly.length >= 6) {
            polyContours.push(curPoly);
            curPoly = [];
            curPt = undefined;
          }

        } else {
          console.error(`verb not supported: ${verb}`);
        }
        lastVerb = verb;
      });

      return {
        polyContours: polyContours,
        earPoints: earPoints,
        quadEars: quadEars,
      }
    }

    // create buffer for pattern that use special shader to draw 
    function addPattern(
      x, y, scale, rotation,
      color, shapeInfo, yInverted, fillType = FillType.SOLID) {

    }

    // create buffer and add the shape to scene
    function addShape(x, y, scale, color, shapeInfo, yInverted, fillType = FillType.SOLID) {
      // create buffer for innerPoly 
      const tessellatedPoly = tessellate(shapeInfo.polyContours);
      // fake winding and texcoord just make the shader code uniform to handle internal and ears
      let fakeWindings = [];
      let fakeTexcoord = [];
      let fillTexCoord = [];

      // compute bounds
      let bounds = {
        minX: 1e9,
        maxX: -1e9,
        minY: 1e9,
        maxY: -1e9,
      };

      for (let i = 0; i < tessellatedPoly.vertices.length / 2; i++) {
        const x = tessellatedPoly.vertices[2 * i + 0];
        const y = tessellatedPoly.vertices[2 * i + 1];
        bounds.minX = Math.min(bounds.minX, x);
        bounds.maxX = Math.max(bounds.maxX, x);
        bounds.minY = Math.min(bounds.minY, y);
        bounds.maxY = Math.max(bounds.maxY, y);
      }
      const extX = bounds.maxX - bounds.minX;
      const extY = bounds.maxY - bounds.minY;

      for (let i = 0; i < tessellatedPoly.vertices.length / 2; i++) {
        fakeWindings.push(0.0);
        fakeTexcoord.push(0.0, 0.0);
        const x = (tessellatedPoly.vertices[2 * i + 0] - bounds.minX) / extX;
        const y = (tessellatedPoly.vertices[2 * i + 1] - bounds.minY) / extY;
        fillTexCoord.push(x, y);
      }

      const polyBuffer = twgl.createBufferInfoFromArrays(gl, {
        a_position: {
          numComponents: 2,
          data: Float32Array.from(tessellatedPoly.vertices),
        },

        a_winding: {
          numComponents: 1,
          data: fakeWindings,
        },

        // texture coord for curve rendering
        a_texcoord: {
          numComponents: 2,
          data: fakeTexcoord,
        },

        // real texture coord
        a_fillTexcoord: {
          numComponents: 2,
          data: fillTexCoord,
        },

        indices: Array.from(tessellatedPoly.triangles),
      });

      // extra buffer for wireframe, for debug purpose
      const polyWireBuffer = twgl.createBufferInfoFromArrays(gl, {
        a_position: {
          numComponents: 2,
          data: Float32Array.from(tessellatedPoly.vertices),
        },
        indices: Array.from(trianglesTolines(tessellatedPoly.triangles)),
      });

      // add to scene
      scene.push({ x: x, y: y, rotation: 0, scale: scale, color: color, bufferInfo: polyBuffer, bufferWire: polyWireBuffer, hasCurve: false, yInverted: yInverted, fillType: fillType });

      // ear data to draw curves
      if (shapeInfo.quadEars.length === 0) return;
      const nEars = shapeInfo.quadEars.length;
      let pts = []; // vertices
      let uv = [];
      let windings = [];
      fillTexCoord = [];
      // let indices = [];

      for (let i = 0; i < nEars; i++) {
        const earData = shapeInfo.quadEars[i];
        for (let k = 0; k < 3; k++) {
          const idx = earData[k];
          const px = shapeInfo.earPoints[2 * idx];
          const py = shapeInfo.earPoints[2 * idx + 1];
          pts.push(px, py);
          fillTexCoord.push((px - bounds.minX) / extX, (py - bounds.minY) / extY);
        }

        uv.push(0, 0, 0.5, 0, 1, 1);
        // indices.push(earData[0], earData[1], earData[2]);
        windings.push(earData[3], earData[3], earData[3]);

      }

      const curveBuffer = twgl.createBufferInfoFromArrays(gl, {
        a_position: {
          numComponents: 2,
          data: pts,
        },
        // for ear rendering
        a_texcoord: {
          numComponents: 2,
          data: uv,
        },
        // image fill coord
        a_fillTexcoord: {
          numComponents: 2,
          data: fillTexCoord,
        },
        a_winding: {
          numComponents: 1,
          data: windings,
        },
        // indices: indices,
      });

      // add to scene
      scene.push({ x: x, y: y, rotation: 0, scale: scale, color: color, bufferInfo: curveBuffer, hasCurve: true, yInverted: yInverted, fillType: fillType });
    }

    function trianglesTolines(triangles) {
      let lines = [];
      for (let i = 0; i < triangles.length / 3; i++) {
        const i0 = triangles[3 * i], i1 = triangles[3 * i + 1], i2 = triangles[3 * i + 2];
        lines.push(i0, i1, i1, i2, i2, i0);
      }
      return lines;
    }

    // compiles shaders, links program, looks up locations
    // const programInfo1 = twgl.createProgramInfo(gl, [vs, fs]);
    const programInfo2 = twgl.createProgramInfo(gl, [loopvs_gl2, loopfs_gl2]);

    // tessellator, a contour is a flattened point-list, and a polygon is a multi-contour
    var ring = [
      [0, 0, 100, 0, 100, 100, 0, 100],
      [20, 20, 80, 20, 80, 80, 20, 80],
    ];
    var tessRing = tessellate(ring);
    const bufferRing = twgl.createBufferInfoFromArrays(gl, {
      a_position: {
        numComponents: 2,
        data: Float32Array.from(tessRing.vertices),
      },
      indices: Array.from(tessRing.triangles),
    });
    const bufferRingWire = twgl.createBufferInfoFromArrays(gl, {
      a_position: {
        numComponents: 2,
        data: Float32Array.from(tessRing.vertices),
      },
      indices: Array.from(trianglesTolines(tessRing.triangles)),
    });

    // shape F
    var poly = [
      [
        0, 0,   // 0----1
        40, 0,  // |    |
        40, 10, // | 3--2
        10, 10, // | |
        10, 20, // | 4-5
        30, 20, // |   |
        30, 30, // | 7-6
        10, 30, // | |
        10, 50, // 9-8
        0, 50,
      ],
    ];

    var tess = tessellate(poly);
    const bufferTess = twgl.createBufferInfoFromArrays(gl, {
      a_position: {
        numComponents: 2,
        data: Float32Array.from(tess.vertices),
      },
      indices: Uint16Array.from(tess.triangles),
    });

    const bufferTessWire = twgl.createBufferInfoFromArrays(gl, {
      a_position: {
        numComponents: 2,
        data: Float32Array.from(tess.vertices),
      },
      indices: Uint16Array.from(trianglesTolines(tess.triangles)),
    });

    // calls gl.createBuffer, gl.bindBuffer, gl.bufferData
    // const bufferInfo = twgl.createBufferInfoFromArrays(gl, {
    //   a_position: {
    //     numComponents: 2,
    //     data: [
    //       0, 0, // 0----1
    //       40, 0, // |    |
    //       40, 10, // | 3--2
    //       10, 10, // | |
    //       10, 20, // | 4-5
    //       30, 20, // |   |
    //       30, 30, // | 7-6
    //       10, 30, // | |
    //       10, 50, // 9-8
    //       0, 50,
    //     ],
    //   },
    //   indices: [
    // 0, 1, 2,
    // 0, 2, 3,
    // 0, 3, 8,
    // 0, 8, 9,
    // 4, 5, 6,
    // 4, 6, 7,
    //   ],
    // });

    const bufferCurve = twgl.createBufferInfoFromArrays(gl, {
      a_position: {
        numComponents: 2,
        data: [
          // 99, 202,
          // 99, 98,
          // 21, 42,
          50, 50,
          100, 50,
          100, 100,

          100, 100,
          50, 100,
          50, 150,
        ],
      },
      a_texcoord: {
        numComponents: 2,
        data: [
          0, 0,
          0.5, 0,
          1, 1,
          0, 0,
          0.5, 0,
          1, 1,
        ],
      },
      a_winding: {
        numComponents: 1,
        data: [1, 1, 1, -1, -1, -1],
      },
      // indices: [
      //   0, 1, 2,
      //   2, 3, 4,
      // ],
    });

    const sphereVerts = twgl.primitives.createSphereVertices(1, 24, 12);
    const sphereBufferInfo = twgl.createBufferInfoFromArrays(gl, {
      a_position: sphereVerts.position,
      indices: sphereVerts.indices,
    });

    const camera = {
      x: -140,
      y: -1,
      rotation: 0,
      zoom: 1.67,
    };

    // add some simple shapes
    const testCubic = shapeFromSvgString('M0,50L50,50C75,50,100,75,100,100C75,100,50,125,50,150z'); // original path
    const strokeString = 'M0 0L50 100C50 95.507 50.8075 91.014 52.2773 86.6661C58.986 66.8215 79.493 50 100 50C100 47.3256 99.7139 44.6512 99.1723 42.0075C94.6512 19.9373 72.3256 0 50 0H0ZM12.9443 8L47.5492 77.21C50.6921 70.81 54.9897 64.9466 59.9681 59.9681C68.3948 51.5415 79.3566 45.0655 91.1649 42.8382C89.4153 35.1888 85.0006 27.5643 78.7181 21.2819C70.4659 13.0296 59.8981 8 50 8H12.9443Z';
    var reversedStrokeString = SVGPathEditor.reverse(strokeString); // have to reverse, winding is not correct.
    const testCubicStroke = shapeFromSvgString(reversedStrokeString); // stroked path (5)
    addShape(-50, 0, 1, [1, 0, 0, 0.5], testCubic, false, FillType.SOLID);
    addShape(50, 0, 1, [1, 0, 0, 0.5], testCubic, false, FillType.ADVANCED_IMAGE);
    addShape(150, 0, 1, [0, 0, 1, 0.9], testCubic, false, FillType.GRADIENT);
    addShape(250, 0, 1, [0, 0, 1, 0.5], testCubic, false, FillType.IMAGE);
    // addShape(350, 50, 1, [0, 0, 1, 1], testCubicStroke, false);

    const blobString = "M -60.48,12.9 C -70.783,-24.08,-114.688,-53.32,-112,-77.4 C -109.312,-101.48,-77.0,-108.79,-47.0-107.5 C -17.024,-106.21,13.4,-94.6,38.0,-70.94 C 62.7,-47.2,77.056,-22.7,76.16,10.75 C 75.264,44.2,60.928,77.4,33.5,96.75 C 6.2,116.1,-41.664,124.27,-60.48,107.5 C -79.2,90.73,-50.1,49.8,-60.48,12.9 Z";
    const blob = shapeFromSvgString(blobString);
    addShape(0, 220, .5, [1, 0, 0, 0.5], blob, false, FillType.SOLID);
    addShape(120, 220, .5, [1, 0, 0, 0.5], blob, false, FillType.ADVANCED_IMAGE);
    addShape(240, 220, .5, [0, 0, 1, 0.9], blob, false, FillType.GRADIENT);
    addShape(360, 220, .5, [0, 0, 1, 0.5], blob, false, FillType.IMAGE);

    // other shapes
    addShape(-500, 100, 0.3, [0.6, 0.25, 0.25, 1], shapeFromSvgString(SvgPath('M202 58C202 88.9279 156.781 114 101 114C45.2192 114 0 88.9279 0 58C0 27.0721 45.2192 0.5 101 0.5C156.781 0.5 202 27.0721 202 58Z').unarc().toString()), false); // oval
    addShape(-500, 200, 0.3, [0.6, 0.25, 0.25, 1], shapeFromSvgString(SvgPath(`M128.596 52.5962C131.135 50.0578 131.135 45.9422 128.596 43.4038L87.2304 2.03806C84.692 -0.500349 80.5765 -0.500349 78.0381 2.03806C75.4997 4.57647 75.4997 8.69204 78.0381 11.2304L114.808 48L78.0381 84.7696C75.4997 87.308 75.4997 91.4235 78.0381 93.9619C80.5765 96.5003 84.692 96.5003 87.2304 93.9619L128.596 52.5962ZM0 54.5H124V41.5H0L0 54.5Z`).unarc().scale(1, -1).toString()), true);
    addShape(-500, 300, 0.3, [0.2, 0.5, 0, 1], shapeFromSvgString(SvgPath(`M73 0L145.746 114H0.253868L73 0Z`).unarc().toString()), false);
    addShape(-500, 400, 0.3, [0.2, 0.5, 0, 1], shapeFromSvgString(SvgPath(`M40.1402 9.42085C48.0031 -2.90099 65.9969 -2.90099 73.8598 9.42085L110.118 66.2414C118.614 79.5548 109.052 97 93.2585 97H20.7415C4.94839 97 -4.61391 79.5548 3.88168 66.2414L40.1402 9.42085Z`).unarc().toString()), false);
    addShape(-500, 500, 0.3, [0.2, 0, 1, 1], shapeFromSvgString(SvgPath(`M65.014 4.2216C71.6822 -0.161684 80.3178 -0.161691 86.986 4.22159L142.729 40.8641C150.449 45.9389 153.689 55.6413 150.566 64.3364L130.129 121.245C127.276 129.188 119.745 134.485 111.306 134.485H40.6942C32.2548 134.485 24.7236 129.188 21.8712 121.245L1.43404 64.3364C-1.68855 55.6413 1.55092 45.939 9.2711 40.8641L65.014 4.2216Z`).unarc().toString()), false);
    addShape(-500, 600, 0.3, [0.2, 0, 1, 1], shapeFromSvgString(SvgPath(`M80 0L159.889 52.5147L129.374 137.485H30.626L0.111252 52.5147L80 0Z`).unarc().toString()), false);
    addShape(-500, 700, 0.3, [0, 0, 1, 0.5], shapeFromSvgString(SvgPath(`M79.5 0L98.2469 53.5512L158.913 53.5512L109.833 86.6476L128.58 140.199L79.5 107.102L30.4199 140.199L49.1668 86.6476L0.0867844 53.5512L60.7531 53.5512L79.5 0Z`).unarc().toString()), false);
    addShape(-500, 800, 0.3, [0, 0, 0.7, 1], shapeFromSvgString(SvgPath(`M0 24C0 10.7452 10.7452 0 24 0H102H180C193.255 0 204 10.7452 204 24V94C204 107.255 193.255 118 180 118H24C10.7452 118 0 107.255 0 94V24Z`).unarc().toString()), false);

    // contains the different shapes, each shape has polylines and ears.
    scene.push(
      // { x: 20, y: 20, rotation: 0, scale: 1, color: [1, 0, 0, 1], bufferInfo: bufferInfo },
      // { x: -500, y: -200, rotation: 0, scale: 1, color: [1, 0, 1, 0.5], bufferInfo: bufferRing, bufferWire: bufferRingWire, hasCurve: false },
      // { x: -500 + 30, y: -200 + 30, rotation: 0, scale: 1, color: [0, 0, 1, 0.5], bufferInfo: bufferRing, bufferWire: bufferRingWire, hasCurve: false },
      // { x: -500, y: 0, rotation: 0, scale: 1, color: [0, 0, 1, 1], bufferInfo: bufferTess, bufferWire: bufferTessWire, hasCurve: false },
      // { x: 400, y: 0, rotation: 0, scale: 1, color: [1, 0, 0, 1], bufferInfo: bufferCurve, hasCurve: true },
    );

    let viewProjectionMat;

    function makeCameraMatrix() {
      const zoomScale = 1 / camera.zoom;
      let cameraMat = m3.identity();
      cameraMat = m3.translate(cameraMat, camera.x, camera.y);
      cameraMat = m3.rotate(cameraMat, camera.rotation);
      cameraMat = m3.scale(cameraMat, zoomScale, zoomScale);
      return cameraMat;
    }

    function updateViewProjection() {
      // same as ortho(0, width, height, 0, -1, 1)
      const projectionMat = m3.projection(gl.canvas.width, gl.canvas.height);
      const cameraMat = makeCameraMatrix();
      let viewMat = m3.inverse(cameraMat);
      viewProjectionMat = m3.multiply(projectionMat, viewMat);
    }

    function drawThing(thing, programInfo) {
      const { x, y, rotation, scale, color, yInverted, fillType } = thing;
      const bufferInfo = showWireframe ? thing.bufferWire : thing.bufferInfo;

      // calls gl.bindBuffer, gl.enableVertexAttribArray, gl.vertexAttribPointer
      if (!bufferInfo) return;
      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);

      let mat = m3.identity();
      mat = m3.translate(mat, x, y);
      mat = m3.rotate(mat, rotation);

      // handle fonts
      if (yInverted) {
        mat = m3.scale(mat, scale, -scale);
      } else {
        mat = m3.scale(mat, scale, scale);
      }

      // calls gl.uniformXXX
      twgl.setUniforms(programInfo, {
        u_matrix: m3.multiply(viewProjectionMat, mat),
        u_color: color,
        u_fillType: fillType ? fillType : FillType.SOLID,
        u_fillSampler: fill_texture,
        u_backgroundSampler: background_texture,
      });

      // calls gl.drawArrays or gl.drawElements
      twgl.drawBufferInfo(gl, bufferInfo, showWireframe ? gl.LINES : gl.TRIANGLES);
    }

    function draw() {
      gl.clearColor(1, 1, 1, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      updateViewProjection();

      gl.useProgram(programInfo2.program);
      for (let i = 0; i < scene.length; i++) {
        drawThing(scene[i], programInfo2);
      }

      // if (rotate) {
      //   drawThing({
      //     x: startPos[0],
      //     y: startPos[1],
      //     rotation: 0,
      //     scale: 5 / camera.zoom,
      //     color: [0, 0, 0, 1],
      //     bufferInfo: sphereBufferInfo,
      //   }, programInfo2);
      // }
    }

    function getClipSpaceMousePosition(e) {
      // get canvas relative css position
      const rect = canvas.getBoundingClientRect();
      const cssX = e.clientX - rect.left;
      const cssY = e.clientY - rect.top;

      // get normalized 0 to 1 position across and down canvas
      const normalizedX = cssX / canvas.clientWidth;
      const normalizedY = cssY / canvas.clientHeight;

      // convert to clip space
      const clipX = normalizedX * 2 - 1;
      const clipY = normalizedY * -2 + 1;

      return [clipX, clipY];
    }

    let startInvViewProjMat;
    let startCamera;
    let startPos;
    let startClipPos;
    let startMousePos;
    let rotate;

    function moveCamera(e) {
      const pos = m3.transformPoint(
        startInvViewProjMat,
        getClipSpaceMousePosition(e));

      camera.x = startCamera.x + startPos[0] - pos[0];
      camera.y = startCamera.y + startPos[1] - pos[1];
      draw();
    }

    function rotateCamera(e) {
      const delta = (e.clientX - startMousePos[0]) / 100;

      // compute a matrix to pivot around the camera space startPos
      let camMat = m3.identity();
      camMat = m3.translate(camMat, startPos[0], startPos[1]);
      camMat = m3.rotate(camMat, delta);
      camMat = m3.translate(camMat, -startPos[0], -startPos[1]);

      // multply in the original camera matrix
      Object.assign(camera, startCamera);
      camMat = m3.multiply(camMat, makeCameraMatrix());

      // now we can set the rotation and get the needed
      // camera position from the matrix
      camera.rotation = startCamera.rotation + delta;
      camera.x = camMat[6];
      camera.y = camMat[7];

      draw();
    }

    function handleMouseMove(e) {
      if (rotate) {
        rotateCamera(e);
      } else {
        moveCamera(e);
      }
    }

    function handleMouseUp(e) {
      console.log(camera);
      rotate = false;
      draw();
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('mouseup', handleMouseUp);
    }

    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('mouseup', handleMouseUp);

      rotate = e.shiftKey;
      startInvViewProjMat = m3.inverse(viewProjectionMat);
      startCamera = Object.assign({}, camera);
      startClipPos = getClipSpaceMousePosition(e);
      startPos = m3.transformPoint(
        startInvViewProjMat,
        startClipPos);
      startMousePos = [e.clientX, e.clientY];
      draw();
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const [clipX, clipY] = getClipSpaceMousePosition(e);

      // position before zooming
      const [preZoomX, preZoomY] = m3.transformPoint(
        m3.inverse(viewProjectionMat),
        [clipX, clipY]);

      // multiply the wheel movement by the current zoom level
      // so we zoom less when zoomed in and more when zoomed out
      const newZoom = camera.zoom * Math.pow(2, e.deltaY * -0.01);
      camera.zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
      window.document.title = `Zoom ${Math.ceil(camera.zoom * 100)}%`;


      updateViewProjection();

      // position after zooming
      const [postZoomX, postZoomY] = m3.transformPoint(
        m3.inverse(viewProjectionMat),
        [clipX, clipY]);

      // camera needs to be moved the difference of before and after
      camera.x += preZoomX - postZoomX;
      camera.y += preZoomY - postZoomY;
      draw();
    });

    // key listener
    window.addEventListener('keydown', (e) => {
      if (e.key === 'w' || e.key === 'W') {
        showWireframe = !showWireframe;
      }
      draw();
    }, false);


    draw();
  </script>
</body>

</html>